// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: loan.sql

package db

import (
	"context"
	"time"
)

const createLoan = `-- name: CreateLoan :one
INSERT INTO loans (
  amount,
  amount_need_to_pay,
  term,
  approval_status,
  repayment_status,
  created_by,
  last_updated_by,
  ip_from,
  user_agent
) VALUES (
  $1, $2,$3,$4,$5,$6,$7,$8,$9
)
RETURNING id, amount, amount_need_to_pay, term, approval_status, is_active, repayment_status, created_by, created_at, last_updated_by, updated_at, ip_from, user_agent
`

type CreateLoanParams struct {
	Amount          string             `json:"amount"`
	AmountNeedToPay string             `json:"amount_need_to_pay"`
	Term            int32              `json:"term"`
	ApprovalStatus  EnumApprovalStatus `json:"approval_status"`
	RepaymentStatus EnumPaymentStatus  `json:"repayment_status"`
	CreatedBy       string             `json:"created_by"`
	LastUpdatedBy   string             `json:"last_updated_by"`
	IpFrom          string             `json:"ip_from"`
	UserAgent       string             `json:"user_agent"`
}

func (q *Queries) CreateLoan(ctx context.Context, arg CreateLoanParams) (Loan, error) {
	row := q.db.QueryRowContext(ctx, createLoan,
		arg.Amount,
		arg.AmountNeedToPay,
		arg.Term,
		arg.ApprovalStatus,
		arg.RepaymentStatus,
		arg.CreatedBy,
		arg.LastUpdatedBy,
		arg.IpFrom,
		arg.UserAgent,
	)
	var i Loan
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.AmountNeedToPay,
		&i.Term,
		&i.ApprovalStatus,
		&i.IsActive,
		&i.RepaymentStatus,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.LastUpdatedBy,
		&i.UpdatedAt,
		&i.IpFrom,
		&i.UserAgent,
	)
	return i, err
}

const deleteLoan = `-- name: DeleteLoan :exec
UPDATE loans SET 
is_active=false
WHERE id = $1 RETURNING id, amount, amount_need_to_pay, term, approval_status, is_active, repayment_status, created_by, created_at, last_updated_by, updated_at, ip_from, user_agent
`

func (q *Queries) DeleteLoan(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteLoan, id)
	return err
}

const getLoan = `-- name: GetLoan :one
SELECT id, amount, amount_need_to_pay, term, approval_status, is_active, repayment_status, created_by, created_at, last_updated_by, updated_at, ip_from, user_agent FROM loans
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetLoan(ctx context.Context, id int64) (Loan, error) {
	row := q.db.QueryRowContext(ctx, getLoan, id)
	var i Loan
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.AmountNeedToPay,
		&i.Term,
		&i.ApprovalStatus,
		&i.IsActive,
		&i.RepaymentStatus,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.LastUpdatedBy,
		&i.UpdatedAt,
		&i.IpFrom,
		&i.UserAgent,
	)
	return i, err
}

const listDescLoan = `-- name: ListDescLoan :many
SELECT id, amount, amount_need_to_pay, term, approval_status, is_active, repayment_status, created_by, created_at, last_updated_by, updated_at, ip_from, user_agent FROM loans 
ORDER BY id  DESC
LIMIT $1 OFFSET $2
`

type ListDescLoanParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListDescLoan(ctx context.Context, arg ListDescLoanParams) ([]Loan, error) {
	rows, err := q.db.QueryContext(ctx, listDescLoan, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Loan{}
	for rows.Next() {
		var i Loan
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.AmountNeedToPay,
			&i.Term,
			&i.ApprovalStatus,
			&i.IsActive,
			&i.RepaymentStatus,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.LastUpdatedBy,
			&i.UpdatedAt,
			&i.IpFrom,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoan = `-- name: ListLoan :many
SELECT id, amount, amount_need_to_pay, term, approval_status, is_active, repayment_status, created_by, created_at, last_updated_by, updated_at, ip_from, user_agent FROM loans 
ORDER BY id 
LIMIT $1 OFFSET $2
`

type ListLoanParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListLoan(ctx context.Context, arg ListLoanParams) ([]Loan, error) {
	rows, err := q.db.QueryContext(ctx, listLoan, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Loan{}
	for rows.Next() {
		var i Loan
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.AmountNeedToPay,
			&i.Term,
			&i.ApprovalStatus,
			&i.IsActive,
			&i.RepaymentStatus,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.LastUpdatedBy,
			&i.UpdatedAt,
			&i.IpFrom,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLoan = `-- name: UpdateLoan :one
UPDATE loans SET 
amount=$2,
amount_need_to_pay=$3,
term=$4,
approval_status=$5,
repayment_status=$6,
last_updated_by=$7,
updated_at=$8
WHERE id = $1 RETURNING id, amount, amount_need_to_pay, term, approval_status, is_active, repayment_status, created_by, created_at, last_updated_by, updated_at, ip_from, user_agent
`

type UpdateLoanParams struct {
	ID              int64              `json:"id"`
	Amount          string             `json:"amount"`
	AmountNeedToPay string             `json:"amount_need_to_pay"`
	Term            int32              `json:"term"`
	ApprovalStatus  EnumApprovalStatus `json:"approval_status"`
	RepaymentStatus EnumPaymentStatus  `json:"repayment_status"`
	LastUpdatedBy   string             `json:"last_updated_by"`
	UpdatedAt       time.Time          `json:"updated_at"`
}

func (q *Queries) UpdateLoan(ctx context.Context, arg UpdateLoanParams) (Loan, error) {
	row := q.db.QueryRowContext(ctx, updateLoan,
		arg.ID,
		arg.Amount,
		arg.AmountNeedToPay,
		arg.Term,
		arg.ApprovalStatus,
		arg.RepaymentStatus,
		arg.LastUpdatedBy,
		arg.UpdatedAt,
	)
	var i Loan
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.AmountNeedToPay,
		&i.Term,
		&i.ApprovalStatus,
		&i.IsActive,
		&i.RepaymentStatus,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.LastUpdatedBy,
		&i.UpdatedAt,
		&i.IpFrom,
		&i.UserAgent,
	)
	return i, err
}

const updateLoanStatus = `-- name: UpdateLoanStatus :one
UPDATE loans SET 
approval_status=$2,
last_updated_by=$3,
updated_at=$4
WHERE id = $1 RETURNING id, amount, amount_need_to_pay, term, approval_status, is_active, repayment_status, created_by, created_at, last_updated_by, updated_at, ip_from, user_agent
`

type UpdateLoanStatusParams struct {
	ID             int64              `json:"id"`
	ApprovalStatus EnumApprovalStatus `json:"approval_status"`
	LastUpdatedBy  string             `json:"last_updated_by"`
	UpdatedAt      time.Time          `json:"updated_at"`
}

func (q *Queries) UpdateLoanStatus(ctx context.Context, arg UpdateLoanStatusParams) (Loan, error) {
	row := q.db.QueryRowContext(ctx, updateLoanStatus,
		arg.ID,
		arg.ApprovalStatus,
		arg.LastUpdatedBy,
		arg.UpdatedAt,
	)
	var i Loan
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.AmountNeedToPay,
		&i.Term,
		&i.ApprovalStatus,
		&i.IsActive,
		&i.RepaymentStatus,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.LastUpdatedBy,
		&i.UpdatedAt,
		&i.IpFrom,
		&i.UserAgent,
	)
	return i, err
}
